I"_"<p>想要理解Java的异常处理机制，只要掌握好这五个keywords 就可以了。<br /></p>
<h4 id="try-catch-finally-throw-和-throws-"><strong>try</strong>, <strong>catch</strong>, <strong>finally</strong>, <strong>throw</strong> 和 <strong>throws</strong> <br /></h4>
<p>一个常用的异常捕获流程如下图所示，</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
    <span class="n">需要监听异常的代码</span><span class="o">;</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
    <span class="n">异常处理代码</span><span class="o">;</span>   
<span class="o">}</span><span class="k">finally</span><span class="o">{</span>
    <span class="n">资源释放代码</span><span class="o">;</span> <span class="c1">//此段代码无论有无异常发生都会执行。</span>
<span class="o">}</span>
</code></pre></div></div>
<p>此外还有try-catch,try-finally的用法，是try-catch-finally的不同功能的组合。
我们也可以在try的后面跟若干个catch，用于捕获多个异常。
值得注意的是，无论有无执行到catch语句(捕获异常)<strong>finally里面的代码一定会被执行</strong>,执行的时间点是在try或者catch的return或者throw语句之前。也就是说在程序退出前会执行到finally包括的语句，然后回来执行try或者catch块中的return或者throw语句。如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。
如果finally块中抛出异常则会覆盖前面try或者catch块中的异常。</p>

<p><strong>throw</strong> 用来主动抛出异常。<br />
<strong>throws</strong> 用在方法的声明当中，如果该方法声明throws一个异常，则表明该方法里可以不处理该异常，有JVM将异常传递里上层调用者处理。
throw通常和throws联合使用，抛出的是程序中已经产生的异常类实例。</p>

<h4 id="java-异常分类"><strong>JAVA 异常分类</strong><br /></h4>
<p>看完了异常处理的流程，我们再来看看Java异常的分类。
Java的异常都来源于一个接口throwable，throwable是java.lang包里的一个接口。继承java.lang.Object.其中有两个直接子类<strong>ERROR</strong>和<strong>EXCEPTION</strong>，有兴趣可以参考 <a href="https://docs.oracle.com/javase/8/docs/api/">Java 官方文档</a><br />
Throwable 主要提供了如下的一些方法。<br />
<strong>Throwable getCause()</strong><br />
<strong>String    getMessage()</strong><br />
<strong>void      printStackTrace()</strong><br />
<strong>String    toString()</strong><br />
<br />
<strong>ERROR</strong>是指的系统的错误，用户无法处理，比如内存溢出等，只有通过修改程序来更正，因此遇到此类错误会让程序终止运行。<br />
ERROR和子类的关系如下图所示。<br />
<img src="https://gangdong.github.io/daviddong.github.io/assets/image/java-throwable-error.png" alt="Error/subclass" /><br />
<strong>EXCEPTION</strong>指的是运行时的异常，是用户可以进行处理的异常。<br />
EXCEPTION类和子类的关系如下。<br />
<img src="https://gangdong.github.io/daviddong.github.io/assets/image/java-throwable-exception.png" alt="Exception/subclass" /><br /></p>
<h4 id="exception-和-runtimeexception"><strong>Exception</strong> 和 <strong>RuntimeException</strong><br /></h4>
<p>可以看到RuntimeException是Exception的子类，实际上RuntimeException对应的是非检查性异常，用户可以处理也可以不处理，而如何继承的是exception,则为检查性异常，用户必须用try-catch来处理异常。<br />
一个简单的例子。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * example of java exception
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> 
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span> <span class="o">)</span>
    <span class="o">{</span>
        <span class="n">runTimeExFun</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">runTimeExFun</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">RuntimeException</span><span class="o">{</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"new runtime exception!"</span><span class="o">);</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>运行结果</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exception in thread "main" java.lang.RuntimeException: new runtime exception!
        at daviddong.example.exception.App.runTimeExFun(App.java:16)
        at daviddong.example.exception.App.main(App.java:11)
</code></pre></div></div>
<p>可以看出如果函数声明的是抛出一个RuntimeException异常，则主调函数可以选择不用try-catch来处理。我们将throws的异常改为Exception,</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * example of java exception
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> 
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span> <span class="o">)</span>
    <span class="o">{</span>
        <span class="n">runTimeExFun</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">runTimeExFun</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"new runtime exception!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>则会报语法错误“Unhandled exception type ExceptionJava(16777384)”，需要用try-catch来处理异常。<br />
正确代码如下。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * example of java exception
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">runTimeExFun</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">runTimeExFun</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"new runtime exception!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /><br /><br /></p>

<p>作者：David Dong<br />
来源：https://gangdong.github.io/daviddong-blog.github.io/java/android/2019/04/14/bundle.html<br />
转载请注明出处。</p>
:ET